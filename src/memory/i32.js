const SIZE = 32;

class I32
{

    //
    // Constructors
    //

    /**
     * Creates a 32-bit integer using the given bit pattern.
     * 
     * @param {array} bits An array of bits (numbers either 0 or 1) which represent the 32-bit integer.
     */
    constructor( bits, flags = undefined )
    {
        this.bits = bits;

        if ( typeof( flags ) === "undefined" )
        {
            this.flags = {
                overflow: false,
                carry: false,
            };
        }
        else
        {
            this.flags = flags;
            if ( typeof( this.flags.overflow ) === "undefined" ) this.flags.overflow = false;
            if ( typeof( this.flags.carry ) === "undefined" ) this.flags.overflow = false;
        }

        this.flags.zero = bits.reduce( ( a, b ) => a + b, 0 ) == 0;
        this.flags.sign = bits[ 0 ] == 1;
    }

    /**
     * @param {number} value The number to convert to a 32-bit int.
     * @returns {I32} An I32 representing the given number.
     */
    static from( value )
    {
        let negative = value < 0;

        // if it's negative, we're going to pretend that we're -(value + 1),
        // because in 2's complement `value` and `-(value + 1)` have binary
        // representations that are just flipped representations of each other
        if ( negative )
        {
            value = -( value + 1 );
        }

        value |= 0; // truncate decimal

        // grab the bits out of each position
        let bits = [];
        for ( let i = 0; i < SIZE; i++ )
        {
            // grab only the bit we're looking at, and if it's negative, then
            // we're going to flip it
            bits[ i ] = ( ( value >> i ) & 1 ) ^ negative;
        }

        return new I32( bits );
    }

    //
    // Interpretations
    //

    /**
     * @returns {number} The signed representation of this i32.
     */
    get signed()
    {
        let out = 0;
        for ( let i = 0; i < SIZE; i++ )
        {
            out += this.bits[ i ] << i;
        }
        return out;
    }

    /**
     * @returns {number} The unsigned representation of this i32
     */
    get unsigned()
    {
        // highest-order bit must be calculated without bit shifting,
        // because js will perform signed logical shifts, so this will
        // produce a negative number if it's on (which is just plain wrong).
        let out = this.bits[ SIZE - 1 ] * Math.pow( 2, SIZE - 1 );

        for ( let i = 0; i < SIZE - 1; i++ )
        {
            out += this.bits[ i ] << i;
        }
        return out;
    }

    get binary()
    {
        // the bits are in reverse order (i.e. [0] is the right-most bit if you write it
        // out by hand and [31] is the left-most), so we join to string then split it to
        // create a copy of the array, so that the reverse won't modify the original list
        return "0b" + this.bits.join( "" ).split( "" ).reverse().join( "" );
    }

    get hex()
    {
        let str = this.unsigned.toString( 16 ).toUpperCase();

        // make sure that there are enough leading zeros
        let upperBound = SIZE / 4;
        while ( str.length < upperBound )
        {
            str = "0" + str;
        }

        // prefix it with an 0x to denote hex, then we're done
        return "0x" + str;
    }

    //
    // Flag Checks
    //

    /**
     * @returns {boolean} If this number was generated by an operation that tripped
     *                    the overflow flag.
     */
    get overflow()
    {
        return this.flags.overflow;
    }

    /**
     * @returns {boolean} If this number was generated by an operation that tripped
     *                    the carry flag.
     */
    get carry()
    {
        return this.flags.carry;
    }

    /**
     * @returns {boolean} If this number has the zero flag set.
     */
    get zero()
    {
        return this.flags.zero;
    }

    /**
     * @returns {boolean} If this number has the negative flag set.
     */
    get negative()
    {
        return this.flags.negative;
    }

    //
    // Bit-wise Operations
    //

    complement()
    {
        // flip all of the bits
        let bits = [];
        for ( let i = 0; i < SIZE; i++ )
        {
            bits[ i ] = ( this.bits[ i ] ^ 1 );
        }

        // return a new I32 based off of that one
        return new I32( bits );
    }

    negative()
    {
        if ( this.negative )
        {
            return this.sub( 1 ).complement();
        }
        else
        {
            return this.complement().add( 1 );
        }
    }

    add( operand )
    {
        // if the operand is a number, first convert it to an I32
        if ( typeof( operand ) === "number" )
        {
            operand = I32.from( operand );
        }

        let bits = [];
        let carry = 0;
        for ( let i = 0; i < SIZE; i++ )
        {
            let sum = this.bits[ i ] + operand.bits[ i ] + carry;

            bits[ i ] = sum & 1; // use the first position as the output bit
            carry = ( sum >> 1 ) & 1; // use the second position as the carry bit
        }

        // set the overflow and carry flags if necessary
        let flags = ( () => {
            let sameInputSign = this.bits[ SIZE - 1 ] === operand.bits[ SIZE - 1 ];
            let sameOutputSign = this.bits[ SIZE - 1 ] === bits[ SIZE - 1 ];

            return {
                overflow: sameInputSign && !sameOutputSign,
                carry: carry != 0
            };
        } )();

        return new I32( bits, flags );
    }

    sub( operand )
    {
        if ( typeof( operand ) === "number" )
        {
            return this.add( -operand );
        }
        else
        {
            return this.add( operand.negative() );
        }
    }

}

module.exports = I32;
