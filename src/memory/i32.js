
const SIZE = 32;

class I32
{

    //
    // Constructors
    //

    /**
     * Creates a 32-bit integer using the given bit pattern.
     * 
     * @param {array} bits An array of bits (numbers either 0 or 1) which represent the 32-bit integer.
     */
    constructor( bits, flags = undefined )
    {
        this.bits = bits;

        if ( typeof( flags ) === "undefined" )
        {
            this.flags = {
                overflow: false,
                carry: false,
            };
        }
        else
        {
            this.flags = flags;
            if ( typeof( this.flags.overflow ) === "undefined" ) this.flags.overflow = false;
            if ( typeof( this.flags.carry ) === "undefined" ) this.flags.overflow = false;
        }

        this.flags.zero = bits.reduce( ( a, b ) => a + b, 0 ) == 0;
        this.flags.sign = bits[ 0 ] == 1;
    }

    /**
     * @param {number} value The number to convert to a 32-bit int.
     * @returns {I32} An I32 representing the given number.
     */
    static from( value )
    {
        let negative = value < 0;
        value = negative ? -value : value;

        value |= 0; // truncate decimal

        // grab the bits out of each position
        let bits = [];
        for ( let i = 0; i < SIZE; i++ )
        {
            let bit = ( value >> i ) & 1;
            bits[ SIZE - i - 1 ] = bit;
        }

        if ( negative )
        {
            return ( new I32( bits ) ).negative();
        }
        else
        {
            return new I32( bits );
        }
    }

    //
    // Interpretations
    //

    /**
     * @returns {number} The signed representation of this i32.
     */
    get signed()
    {
        // if we're a negative number, then return the negative value of the negative representation
        // of this I32
        if ( this.bits[ 0 ] === 1 )
        {
            return -( this.complement().signed + 1 );
        }
        // if we're a positive number, then just return the unsigned value 
        // (as it won't be different)
        else
        {
            let out = 0;
            for ( let i = 0; i < SIZE; i++ )
            {
                out += this.bits[ i ] << ( SIZE - i - 1 );
            }
            return out;
        }
    }

    /**
     * @returns {number} The unsigned representation of this i32
     */
    get unsigned()
    {
        return parseInt( this.binary.substr( 2 ), 2 );
    }

    get binary()
    {
        // join the bits together without spaces, gg ez
        return "0b" + this.bits.join( "" );
    }

    get hex()
    {
        let str = this.unsigned.toString( 16 ).toUpperCase();

        // make sure that there are enough leading zeros
        let upperBound = SIZE / 4;
        while ( str.length < upperBound )
        {
            str = "0" + str;
        }

        // prefix it with an 0x to denote hex, then we're done
        return "0x" + str;
    }

    //
    // Flag Checks
    //

    /**
     * @returns {boolean} If this number was generated by an operation that tripped
     *                    the overflow flag.
     */
    get overflow()
    {
        return this.flags.overflow;
    }

    /**
     * @returns {boolean} If this number was generated by an operation that tripped
     *                    the carry flag.
     */
    get carry()
    {
        return this.flags.carry;
    }

    /**
     * @returns {boolean} If this number has the zero flag set.
     */
    get zero()
    {
        return this.flags.zero;
    }

    /**
     * @returns {boolean} If this number has the negative flag set.
     */
    get negative()
    {
        return this.flags.negative;
    }

    //
    // Bit-wise Operations
    //

    complement()
    {
        // flip all of the bits
        let bits = [];
        for ( let i = 0; i < SIZE; i++ )
        {
            bits[ i ] = ( this.bits[ i ] ^ 1 );
        }

        // return a new I32 based off of that one
        return new I32( bits );
    }

    negative()
    {
        if ( this.bits[ 0 ] === 0 )
        {
            return this.complement().add( 1 );
        }
        else
        {
            return this.sub( 1 ).complement();
        }
    }

    add( operand )
    {
        // if the operand is a number, first convert it to an I32
        if ( typeof( operand ) === "number" )
        {
            operand = I32.from( operand );
        }

        let bits = [];
        let carry = 0;
        for ( let i = SIZE - 1; i >= 0; i-- )
        {
            let sum = this.bits[ i ] + operand.bits[ i ] + carry;

            bits[ i ] = sum & 1; // use the first position as the output bit
            carry = ( sum >> 1 ) & 1; // use the second position as the carry bit
        }

        // set the overflow and carry flags if necessary
        let flags = {
            overflow: ( operand.bits[ 0 ] === this.bits[ 0 ] ) && ( this.bits[ 0 ] != bits[ 0 ] ),
            carry: carry !== 0,
        };

        return new I32( bits, flags );
    }

    sub( operand )
    {
        if ( typeof( operand ) === "number" )
        {
            return this.add( -operand );
        }
        else
        {
            return this.add( operand.negative() );
        }
    }

}

module.exports = I32;
